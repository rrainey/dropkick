classdef Quaternion
  properties
    q;
  end
  methods
    %% Generate a mmatrix suitable to convert from world coordinated to
    %% body coordinates
    %% See E.2.4 in ANSI/AIAA R-004-1992
    function M = ToMatrix(obj)
      M = transpose( [ ...
        (obj.q(1)^2 + obj.q(2)^2 - obj.q(3)^2 - obj.q(4)^2), ...
        2 * ((obj.q(2)*obj.q(3)) + obj.q(1) * obj.q(4)), ...
        2 * ((obj.q(2)*obj.q(4)) - obj.q(1) * obj.q(3)) ; ...
        2 * ((obj.q(2)*obj.q(3)) - obj.q(1) * obj.q(4)), ...
        (obj.q(1)^2 + obj.q(3)^2 - obj.q(2)^2 - obj.q(4)^2), ...
        2 * ((obj.q(3)*obj.q(4)) + obj.q(1) * obj.q(2)); ...
        2 * ((obj.q(2)*obj.q(4)) + obj.q(1) * obj.q(3)), ...
        2 * ((obj.q(3)*obj.q(4)) - obj.q(1) * obj.q(2)), ...
        (obj.q(1)^2 + obj.q(4)^2 - obj.q(2)^2 - obj.q(3)^2) ...
      ]);
    end

    %% Extract Euler angles from Quaternion object
    %% See E.2.3 in ANSI/AIAA R-004-1992
    function [phi, theta, psi] = ToEuler(obj)
      phi = atan2(2 * (obj.q(3) * obj.q(4) + obj.q(1) * obj.q(2)), (obj.q(1)^2 +obj.q(4)^2 -obj.q(2)^2-obj.q(3)^2));
      theta = asin( -2 * (obj.q(2) * obj.q(4) - obj.q(1) * obj.q(3)));
      psi = atan2(2 * (obj.q(2) * obj.q(3) + obj.q(1) * obj.q(4)), (obj.q(1)^2 +obj.q(2)^2 - obj.q(3)^2 - obj.q(4)^2));
      if (psi < 0.0)
        psi += 2.0 * DMath.Pi;
      end
    end

    %% Initialize from AIAA Euler body angles
    %% See E.2.1 in ANSI/AIAA R-004-1992
    function obj = Quaternion(phi, theta, psi)
      obj.q = [ 
          cos(psi/2) * cos(theta/2) * cos(phi/2) + sin(psi/2) * sin(theta/2) * sin(phi/2); ...
          cos(psi/2) * cos(theta/2) * sin(phi/2) - sin(psi/2) * sin(theta/2) * cos(phi/2); ...
          cos(psi/2) * sin(theta/2) * cos(phi/2) + sin(psi/2) * cos(theta/2) * sin(phi/2); ...
        - cos(psi/2) * sin(theta/2) * sin(phi/2) + sin(psi/2) * cos(theta/2) * cos(phi/2); ...
        ];
    end
  endmethods
endclassdef